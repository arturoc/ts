{
    "task.allowAutomaticTasks": "on",
    "webgl-glsl-editor.codeInjection": true,
    "webgl-glsl-editor.codeInjectionSource": [
        "#version 300 es",
        "precision highp float;",
        "precision highp int;",
        "precision highp usampler2D;",
        "// shared/global stuff\r",
        "#define PASS_COLOR 0\r",
        "#define PASS_PICK 1\r",
        "#define PASS_PRE 2\r",
        "\r",
        "#ifndef PASS\r",
        "#define PASS PASS_COLOR // avoid red squigglies in editor\r",
        "#endif\r",
        "\r",
        "struct CameraUniforms {\r",
        "    mat4 clipViewMatrix;\r",
        "    mat4 viewClipMatrix;\r",
        "    mat4 localViewMatrix;\r",
        "    mat4 viewLocalMatrix;\r",
        "    mat3 localViewMatrixNormal;\r",
        "    mat3 viewLocalMatrixNormal;\r",
        "    vec2 viewSize;\r",
        "    float near; // near clipping plane distance\r",
        "};\r",
        "struct IBLTextures {\r",
        "    samplerCube specular;\r",
        "    samplerCube diffuse;\r",
        "};\r",
        "\r",
        "// background\r",
        "struct BackgroundVaryings {\r",
        "    vec3 dir;\r",
        "};\r",
        "struct BackgroundUniforms {\r",
        "    float envBlurNormalized;\r",
        "    int mipCount;\r",
        "};\r",
        "struct BackgroundTextures {\r",
        "    samplerCube skybox;\r",
        "    IBLTextures ibl;\r",
        "};\r",
        "\r",
        "// clipping\r",
        "const uint undefinedIndex = 7U;\r",
        "const uint clippingId = 0xfffffff0U;\r",
        "const uint clippingModeIntersection = 0U;\r",
        "const uint clippingModeUnion = 1U;\r",
        "struct ClippingVaryings {\r",
        "    vec3 dirVS;\r",
        "};\r",
        "struct ClippingUniforms {\r",
        "    vec4 planes[6];\r",
        "    uint numPlanes;\r",
        "    uint mode; // 0 = intersection, 1 = union\r",
        "};\r",
        "struct ClippingColors {\r",
        "    vec4 colors[6];\r",
        "};\r",
        "bool clip(vec3 point, ClippingUniforms clipping) {\r",
        "    float s = clipping.mode == clippingModeIntersection ? -1. : 1.;\r",
        "    bool inside = clipping.mode == clippingModeIntersection ? clipping.numPlanes > 0U : true;\r",
        "    for(uint i = 0U; i < clipping.numPlanes; i++) {\r",
        "        inside = inside && dot(vec4(point, 1), clipping.planes[i]) * s < 0.;\r",
        "    }\r",
        "    return clipping.mode == clippingModeIntersection ? inside : !inside;\r",
        "}\r",
        "\r",
        "// outlines\r",
        "struct OutlineUniforms {\r",
        "    mat4 localPlaneMatrix;\r",
        "    mat4 planeLocalMatrix;\r",
        "    vec3 color;\r",
        "};\r",
        "\r",
        "bool clipOutlines(vec3 point, ClippingUniforms clipping) {\r",
        "    float s = clipping.mode == clippingModeIntersection ? -1. : 1.;\r",
        "    bool inside = clipping.mode == clippingModeIntersection ? clipping.numPlanes > 0U : true;\r",
        "    for(uint i = 0U; i < clipping.numPlanes; i++) {\r",
        "        inside = inside && dot(vec4(point, 1), clipping.planes[i]) * s < 0.;\r",
        "    }\r",
        "    return !inside;\r",
        "}\r",
        "\r",
        "// cube\r",
        "const uint cubeId = 0xfffffff8U;\r",
        "struct CubeVaryings {\r",
        "    vec3 posVS;\r",
        "    vec3 normal;\r",
        "    vec3 color;\r",
        "};\r",
        "struct CubeUniforms {\r",
        "    mat4 modelLocalMatrix;\r",
        "};\r",
        "\r",
        "// grid\r",
        "struct GridVaryings {\r",
        "    vec2 posOS;\r",
        "    vec3 posLS;\r",
        "};\r",
        "struct GridUniforms {\r",
        "    // below coords are in local space\r",
        "    vec3 origin;\r",
        "    vec3 axisX;\r",
        "    vec3 axisY;\r",
        "    float size1;\r",
        "    float size2;\r",
        "    vec3 color;\r",
        "    float distance;\r",
        "};\r",
        "\r",
        "struct ToonOutlineUniforms {\r",
        "    vec3 color;\r",
        "};\r",
        "\r",
        "// dynamic geometry\r",
        "const vec3 ambientLight = vec3(0);\r",
        "struct DynamicVaryings {\r",
        "    vec4 color0;\r",
        "    vec2 texCoord0;\r",
        "    vec2 texCoord1;\r",
        "    vec3 positionVS;\r",
        "    float linearDepth;\r",
        "    mat3 tbn; // in world space\r",
        "    vec3 toCamera; // in world space (camera - position)\r",
        "};\r",
        "struct DynamicVaryingsFlat {\r",
        "    uint objectId;\r",
        "};\r",
        "struct MaterialUniforms {\r",
        "    vec4 baseColorFactor;\r",
        "    vec3 emissiveFactor;\r",
        "    float roughnessFactor;\r",
        "    float metallicFactor;\r",
        "    float normalScale;\r",
        "    float occlusionStrength;\r",
        "    float alphaCutoff;\r",
        "    int baseColorUVSet;\r",
        "    int metallicRoughnessUVSet;\r",
        "    int normalUVSet;\r",
        "    int occlusionUVSet;\r",
        "    int emissiveUVSet;\r",
        "    uint radianceMipCount;\r",
        "};\r",
        "struct ObjectUniforms {\r",
        "    mat4 worldLocalMatrix;\r",
        "    uint baseObjectId;\r",
        "};\r",
        "struct DynamicTextures {\r",
        "    sampler2D lut_ggx;\r",
        "    IBLTextures ibl;\r",
        "    sampler2D base_color;\r",
        "    sampler2D metallic_roughness;\r",
        "    sampler2D normal;\r",
        "    sampler2D emissive;\r",
        "    sampler2D occlusion;\r",
        "};\r",
        "\r",
        "// octree\r",
        "#define MODE_TRIANGLES 0\r",
        "#define MODE_POINTS 1\r",
        "#define MODE_TERRAIN 2\r",
        "\r",
        "#ifndef MODE\r",
        "#define MODE MODE_TRIANGLES // avoid red squigglies in editor\r",
        "#endif\r",
        "\r",
        "const uint maxHighlights = 256U;\r",
        "struct OctreeVaryings {\r",
        "    vec3 positionVS; // view space\r",
        "    vec3 normalVS; // view space\r",
        "    vec2 texCoord0;\r",
        "    vec2 screenPos;\r",
        "    float radius;\r",
        "    float deviation;\r",
        "    float elevation;\r",
        "};\r",
        "struct OctreeVaryingsFlat {\r",
        "    vec4 color;\r",
        "    uint objectId;\r",
        "    uint highlight;\r",
        "};\r",
        "struct SceneUniforms {\r",
        "    bool applyDefaultHighlight;\r",
        "    float iblMipCount;\r",
        "    // point cloud\r",
        "    float pixelSize;\r",
        "    float maxPixelSize;\r",
        "    float metricSize;\r",
        "    float toleranceFactor;\r",
        "    int deviationIndex;\r",
        "    float deviationFactor;\r",
        "    vec2 deviationRange;\r",
        "    bool useProjectedPosition;\r",
        "    // terrain elevation\r",
        "    vec2 elevationRange;\r",
        "    float pickOpacityThreshold;\r",
        "};\r",
        "struct NodeUniforms {\r",
        "    mat4 modelLocalMatrix;\r",
        "    float tolerance;\r",
        "    vec4 debugColor;\r",
        "    // min,max are in local space\r",
        "    vec3 min;\r",
        "    vec3 max;\r",
        "};\r",
        "const struct OctreeTextures {\r",
        "    sampler2D base_color;\r",
        "    IBLTextures ibl;\r",
        "    sampler2D materials;\r",
        "    sampler2D highlights;\r",
        "    sampler2D gradients;\r",
        "};\r",
        "\r",
        "// watermark\r",
        "struct WatermarkVaryings {\r",
        "    float elevation;\r",
        "};\r",
        "struct WatermarkUniforms {\r",
        "    mat4 modelClipMatrix;\r",
        "    vec4 color;\r",
        "};\r",
        "\r",
        "// tonemapping\r",
        "const float tonemapMaxDeviation = 1.;\r",
        "const uint tonemapModeColor = 0U;\r",
        "const uint tonemapModeNormal = 1U;\r",
        "const uint tonemapModeDepth = 2U;\r",
        "const uint tonemapModeObjectId = 3U;\r",
        "const uint tonemapModeDeviation = 4U;\r",
        "const uint tonemapModeZbuffer = 5U;\r",
        "struct TonemappingVaryings {\r",
        "    vec2 uv;\r",
        "};\r",
        "struct TonemappingUniforms {\r",
        "    float exposure;\r",
        "    uint mode;\r",
        "    float maxLinearDepth;\r",
        "};\r",
        "struct TonemappingTextures {\r",
        "    sampler2D color;\r",
        "    usampler2D pick;\r",
        "    sampler2D zbuffer;\r",
        "};\r",
        "\r",
        "// dither transparency\r",
        "const mat4 ditherThresholds = mat4(0.0 / 16.0, 8.0 / 16.0, 2.0 / 16.0, 10.0 / 16.0, 12.0 / 16.0, 4.0 / 16.0, 14.0 / 16.0, 6.0 / 16.0, 3.0 / 16.0, 11.0 / 16.0, 1.0 / 16.0, 9.0 / 16.0, 15.0 / 16.0, 7.0 / 16.0, 13.0 / 16.0, 5.0 / 16.0);\r",
        "float dither(vec2 xy) {\r",
        "    int x = int(xy.x) & 3;\r",
        "    int y = int(xy.y) & 3;\r",
        "    return ditherThresholds[y][x];\r",
        "}\r",
        "\r",
        "// sRGB\r",
        "const float GAMMA = 2.2;\r",
        "const float INV_GAMMA = 1.0 / GAMMA;\r",
        "// linear to sRGB approximation (http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html)\r",
        "vec3 linearTosRGB(vec3 color) {\r",
        "    return pow(color, vec3(INV_GAMMA));\r",
        "}\r",
        "// sRGB to linear approximation (http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html)\r",
        "vec3 sRGBToLinear(vec3 srgbIn) {\r",
        "    return vec3(pow(srgbIn.xyz, vec3(GAMMA)));\r",
        "}\r",
        "\r",
        "// gradients\r",
        "const float numGradients = 2.;\r",
        "const float deviationV = 0. / numGradients + .5 / numGradients;\r",
        "const float elevationV = 1. / numGradients + .5 / numGradients;\r",
        "\r",
        "vec4 getGradientColor(sampler2D gradientTexture, float position, float v, vec2 range) {\r",
        "    float u = (range[0] >= range[1]) ? 0. : (position - range[0]) / (range[1] - range[0]);\r",
        "    return texture(gradientTexture, vec2(u, v));\r",
        "}\r",
        "\r",
        "// packing\r",
        "\r",
        "// we use octrahedral packing of normals to map 3 components down to 2: https://jcgt.org/published/0003/02/01/\r",
        "vec2 signNotZero(vec2 v) { // returns ±1\r",
        "    return vec2((v.x >= 0.) ? +1. : -1., (v.y >= 0.) ? +1. : -1.);\r",
        "}\r",
        "\r",
        "vec2 float32x3_to_oct(vec3 v) { // assume normalized input. Output is on [-1, 1] for each component.\r",
        "    // project the sphere onto the octahedron, and then onto the xy plane\r",
        "    vec2 p = v.xy * (1. / (abs(v.x) + abs(v.y) + abs(v.z)));\r",
        "    // reflect the folds of the lower hemisphere over the diagonals\r",
        "    return (v.z <= 0.) ? ((1. - abs(p.yx)) * signNotZero(p)) : p;\r",
        "}\r",
        "\r",
        "vec3 oct_to_float32x3(vec2 e) {\r",
        "    vec3 v = vec3(e.xy, 1. - abs(e.x) - abs(e.y));\r",
        "    if(v.z < 0.)\r",
        "        v.xy = (1. - abs(v.yx)) * signNotZero(v.xy);\r",
        "    return normalize(v);\r",
        "}\r",
        "\r",
        "uvec2 packNormalAndDeviation(vec3 normal, float deviation) {\r",
        "    return uvec2(packHalf2x16(normal.xy), packHalf2x16(vec2(normal.z, deviation)));\r",
        "}\r",
        "\r",
        "uvec2 packNormal(vec3 normal) {\r",
        "    return packNormalAndDeviation(normal, 0.);\r",
        "}\r",
        "\r",
        "vec4 unpackNormalAndDeviation(uvec2 normalAndDeviation) {\r",
        "    return vec4(unpackHalf2x16(normalAndDeviation[0]), unpackHalf2x16(normalAndDeviation[1]));\r",
        "}\r",
        ""
    ],
    "typescript.tsdk": "node_modules\\typescript\\lib"
}