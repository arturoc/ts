{
    "task.allowAutomaticTasks": "on",
    "webgl-glsl-editor.codeInjection": true,
    "webgl-glsl-editor.codeInjectionSource": [
        "#version 300 es",
        "precision highp float;",
        "precision highp int;",
        "precision highp usampler2D;",
        "// shared/global stuff\r",
        "struct CameraUniforms {\r",
        "    mat4 clipViewMatrix;\r",
        "    mat4 viewClipMatrix;\r",
        "    mat4 localViewMatrix;\r",
        "    mat4 viewLocalMatrix;\r",
        "    mat3 localViewMatrixNormal;\r",
        "    mat3 viewLocalMatrixNormal;\r",
        "    vec2 viewSize;\r",
        "    float near; // near clipping plane distance\r",
        "};\r",
        "struct IBLTextures {\r",
        "    samplerCube specular;\r",
        "    samplerCube diffuse;\r",
        "};\r",
        "\r",
        "// background\r",
        "struct BackgroundVaryings {\r",
        "    vec3 dir;\r",
        "};\r",
        "struct BackgroundUniforms {\r",
        "    float envBlurNormalized;\r",
        "    int mipCount;\r",
        "};\r",
        "struct BackgroundTextures {\r",
        "    samplerCube skybox;\r",
        "    IBLTextures ibl;\r",
        "};\r",
        "\r",
        "// clipping\r",
        "const uint undefinedIndex = 7U;\r",
        "const uint clippingId = 0xfffffff0U;\r",
        "const uint clippingModeIntersection = 0U;\r",
        "const uint clippingModeUnion = 1U;\r",
        "struct ClippingVaryings {\r",
        "    vec3 dirVS;\r",
        "};\r",
        "struct ClippingUniforms {\r",
        "    vec4 planes[6];\r",
        "    uint numPlanes;\r",
        "    uint mode; // 0 = intersection, 1 = union\r",
        "};\r",
        "struct ClippingColors {\r",
        "    vec4 colors[6];\r",
        "};\r",
        "bool clip(vec3 point, ClippingUniforms clipping) {\r",
        "    float s = clipping.mode == clippingModeIntersection ? -1. : 1.;\r",
        "    bool inside = clipping.mode == clippingModeIntersection ? clipping.numPlanes > 0U : true;\r",
        "    for(uint i = 0U; i < clipping.numPlanes; i++) {\r",
        "        inside = inside && dot(vec4(point, 1), clipping.planes[i]) * s < 0.;\r",
        "    }\r",
        "    return clipping.mode == clippingModeIntersection ? inside : !inside;\r",
        "}\r",
        "\r",
        "// cube\r",
        "const uint cubeId = 0xfffffff8U;\r",
        "struct CubeVaryings {\r",
        "    vec3 posVS;\r",
        "    vec3 normal;\r",
        "    vec3 color;\r",
        "    float linearDepth;\r",
        "};\r",
        "struct CubeUniforms {\r",
        "    mat4 modelLocalMatrix;\r",
        "    vec3 nearOutlineColor;\r",
        "};\r",
        "\r",
        "// grid\r",
        "struct GridVaryings {\r",
        "    vec2 posOS;\r",
        "    vec3 posLS;\r",
        "};\r",
        "struct GridUniforms {\r",
        "    // below coords are in local space\r",
        "    vec3 origin;\r",
        "    vec3 axisX;\r",
        "    vec3 axisY;\r",
        "    float size1;\r",
        "    float size2;\r",
        "    vec3 color;\r",
        "    float distance;\r",
        "};\r",
        "\r",
        "// dynamic geometry\r",
        "const vec3 ambientLight = vec3(0);\r",
        "struct DynamicVaryings {\r",
        "    vec4 color0;\r",
        "    vec2 texCoord0;\r",
        "    vec2 texCoord1;\r",
        "    float linearDepth;\r",
        "    mat3 tbn; // in world space\r",
        "    vec3 toCamera; // in world space (camera - position)\r",
        "};\r",
        "struct MaterialUniforms {\r",
        "    vec4 baseColorFactor;\r",
        "    vec3 emissiveFactor;\r",
        "    float roughnessFactor;\r",
        "    float metallicFactor;\r",
        "    float normalScale;\r",
        "    float occlusionStrength;\r",
        "    float alphaCutoff;\r",
        "    int baseColorUVSet;\r",
        "    int metallicRoughnessUVSet;\r",
        "    int normalUVSet;\r",
        "    int occlusionUVSet;\r",
        "    int emissiveUVSet;\r",
        "    uint radianceMipCount;\r",
        "};\r",
        "struct InstanceUniforms {\r",
        "    mat4 modelLocalMatrix;\r",
        "    mat3 modelLocalMatrixNormal;\r",
        "    uint objectId;\r",
        "};\r",
        "struct DynamicTextures {\r",
        "    sampler2D lut_ggx;\r",
        "    IBLTextures ibl;\r",
        "    sampler2D base_color;\r",
        "    sampler2D metallic_roughness;\r",
        "    sampler2D normal;\r",
        "    sampler2D emissive;\r",
        "    sampler2D occlusion;\r",
        "};\r",
        "\r",
        "// octree\r",
        "const uint maxHighlights = 256U;\r",
        "struct OctreeVaryings {\r",
        "    vec3 positionVS; // view space\r",
        "    vec3 normalWS; // world spaec\r",
        "    vec3 normalVS; // view space\r",
        "    vec2 texCoord0;\r",
        "    float linearDepth;\r",
        "    vec2 screenPos;\r",
        "    float radius;\r",
        "    float deviation;\r",
        "    float elevation;\r",
        "#ifdef IOS_WORKAROUND\r",
        "    vec4 color;\r",
        "    vec2 objectId; // older (<A15) IOS and Ipads crash if we use flat/uint here, so we use two floats instead\r",
        "    float highlight;\r",
        "#endif\r",
        "};\r",
        "#ifndef IOS_WORKAROUND\r",
        "struct OctreeVaryingsFlat {\r",
        "    vec4 color;\r",
        "    uint objectId;\r",
        "    uint highlight;\r",
        "};\r",
        "#endif\r",
        "struct SceneUniforms {\r",
        "    bool applyDefaultHighlight;\r",
        "    float iblMipCount;\r",
        "    // point cloud\r",
        "    float pixelSize;\r",
        "    float maxPixelSize;\r",
        "    float metricSize;\r",
        "    float toleranceFactor;\r",
        "    uint deviationMode;\r",
        "    vec2 deviationRange;\r",
        "    // terrain elevation\r",
        "    vec2 elevationRange;\r",
        "    // outlines\r",
        "    vec3 nearOutlineColor;\r",
        "};\r",
        "struct NodeUniforms {\r",
        "    mat4 modelLocalMatrix;\r",
        "    float tolerance;\r",
        "    vec4 debugColor;\r",
        "    // min,max are in local space\r",
        "    vec3 min;\r",
        "    vec3 max;\r",
        "};\r",
        "const uint meshModeTriangles = 0U;\r",
        "const uint meshModePoints = 1U;\r",
        "const uint meshModeTerrain = 2U;\r",
        "const struct OctreeTextures {\r",
        "    sampler2D base_color;\r",
        "    IBLTextures ibl;\r",
        "    sampler2D materials;\r",
        "    sampler2D highlights;\r",
        "    sampler2D gradients;\r",
        "};\r",
        "\r",
        "// watermark\r",
        "struct WatermarkVaryings {\r",
        "    float elevation;\r",
        "};\r",
        "struct WatermarkUniforms {\r",
        "    mat4 modelClipMatrix;\r",
        "    vec4 color;\r",
        "};\r",
        "\r",
        "// tonemapping\r",
        "const float tonemapMaxDeviation = 1.;\r",
        "const uint tonemapModeColor = 0U;\r",
        "const uint tonemapModeNormal = 1U;\r",
        "const uint tonemapModeDepth = 2U;\r",
        "const uint tonemapModeObjectId = 3U;\r",
        "const uint tonemapModeDeviation = 4U;\r",
        "const uint tonemapModeZbuffer = 5U;\r",
        "struct TonemappingVaryings {\r",
        "    vec2 uv;\r",
        "};\r",
        "struct TonemappingUniforms {\r",
        "    float exposure;\r",
        "    uint mode;\r",
        "    float maxLinearDepth;\r",
        "};\r",
        "struct TonemappingTextures {\r",
        "    sampler2D color;\r",
        "    sampler2D depth;\r",
        "    usampler2D info;\r",
        "    sampler2D zbuffer;\r",
        "};\r",
        "\r",
        "// dither transparency\r",
        "const mat4 ditherThresholds = mat4(0.0 / 16.0, 8.0 / 16.0, 2.0 / 16.0, 10.0 / 16.0, 12.0 / 16.0, 4.0 / 16.0, 14.0 / 16.0, 6.0 / 16.0, 3.0 / 16.0, 11.0 / 16.0, 1.0 / 16.0, 9.0 / 16.0, 15.0 / 16.0, 7.0 / 16.0, 13.0 / 16.0, 5.0 / 16.0);\r",
        "float dither(vec2 xy) {\r",
        "    int x = int(xy.x) & 3;\r",
        "    int y = int(xy.y) & 3;\r",
        "    return ditherThresholds[y][x];\r",
        "}\r",
        "\r",
        "// sRGB\r",
        "const float GAMMA = 2.2;\r",
        "const float INV_GAMMA = 1.0 / GAMMA;\r",
        "// linear to sRGB approximation (http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html)\r",
        "vec3 linearTosRGB(vec3 color) {\r",
        "    return pow(color, vec3(INV_GAMMA));\r",
        "}\r",
        "// sRGB to linear approximation (http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html)\r",
        "vec3 sRGBToLinear(vec3 srgbIn) {\r",
        "    return vec3(pow(srgbIn.xyz, vec3(GAMMA)));\r",
        "}\r",
        "\r",
        "// gradients\r",
        "const float numGradients = 2.;\r",
        "const float deviationV = 0. / numGradients + .5 / numGradients;\r",
        "const float elevationV = 1. / numGradients + .5 / numGradients;\r",
        "\r",
        "vec4 getGradientColor(sampler2D gradientTexture, float position, float v, vec2 range) {\r",
        "    float u = (range[0] >= range[1]) ? 0. : (position - range[0]) / (range[1] - range[0]);\r",
        "    return texture(gradientTexture, vec2(u, v));\r",
        "}\r",
        "\r",
        "// packing\r",
        "uint packNormal(vec2 normal) {\r",
        "    uvec2 nu = uvec2(clamp(normal, -1., 1.) * 127.);\r",
        "    uint n = nu.x & 0xffU | (nu.y & 0xffU) << 8;\r",
        "    return n;\r",
        "}\r",
        "\r",
        "uint packNormalAndDeviation(vec2 normal, float deviation) {\r",
        "    uvec2 nu = uvec2(clamp(normal, -1., 1.) * 127.);\r",
        "    uint n = nu.x & 0xffU | (nu.y & 0xffU) << 8;\r",
        "    uint d = packHalf2x16(vec2(0, deviation));\r",
        "    return n | d;\r",
        "}\r",
        "\r",
        "vec2 unpackNormal(uint normalAndDeviation) {\r",
        "    uint xui = normalAndDeviation >> 0U & 0xffU;\r",
        "    uint yui = normalAndDeviation >> 8U & 0xffU;\r",
        "    float nx = float(xui & 0x7fU) / 127. * ((xui & 0x80U) == 0U ? 1. : -1.);\r",
        "    float ny = float(yui & 0x7fU) / 127. * ((yui & 0x80U) == 0U ? 1. : -1.);\r",
        "    return vec2(nx, ny);\r",
        "}\r",
        "\r",
        "float unpackDeviation(uint normalAndDeviation) {\r",
        "    return unpackHalf2x16(normalAndDeviation).y;\r",
        "}\r",
        ""
    ],
    "typescript.tsdk": "node_modules\\typescript\\lib"
}